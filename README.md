
# HPWalletCore
HPWalletCore is committed to build a straightforward and easy-to-use cross platform wallet library.
It proposed an unified API suite, which allows users to generate or import BTC, ETH, ETC, LTC, DASH, DOGE, QTUM and USDT tokens' private keys, public key and addresses. It also provided corresponding methods in generating raw transactions of the coins and signing of the transactions.

In addition, it is different to other third-party wallet schemes: when generating mnemonics or private keys, the HPWalletCore allowed optional parameters of the mobile phone's UDID and password to encrypt the secret. When user choose to use this added extra layer in mnemonics or private keys generation, it will provide an additional layer of security to the digital assets. Even if the mnemonics is leaked, adversaries cannot access to your digital assets without first knowing the phone's UDID and the password you set. This way, it hopefully can provide a good enough security for your digital assets.


For a Chinese version of the README file, please see the link below:
[‰∏≠ÊñáÁâàüá®üá≥](https://github.com/hyperpayorg/hyperpaywallet/blob/master/README_CN.md)

# HPWalletCore Supports
Currently, HPWalletCore supports generating and importing of mnemonics private keys and raw transactions related operations.
The specific operations that are supported by HPWalletCore are listed in the table below:

|Coin|Mnemonics Support|PrivateKey Support|Transaction Support|Explore|Remark|
|:----:|:----:|:----:|:----:|:----:|:----:|
|BTC|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[DecodeTx](https://live.blockcypher.com/btc/decodetx/)„ÄÅ[Broadcast](https://blockchair.com/broadcast)| |
|BCH|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[PushTx](https://bch.btc.com/16Lp3ZvcusRGtqy7DgF5gz6PGutvuEtwRt)| |
|DASH|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[Broadcast](https://insight.dash.org/insight/tx/send)„ÄÅ[DecodeTx](https://live.blockcypher.com/dash/decodetx/)| |
|DOGE|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[DecodeTx] (https://live.blockcypher.com/doge/decodetx/)„ÄÅ[Broadcast](https://blockchair.com/broadcast)| |
|ETH|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[PushTx](https://etherscan.io/pushTx?%253Flang=zh-CN)„ÄÅ[Broadcast](https://badmofo.github.io/ethsend/)|Support ERC20|
|ETC|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[PushTx](https://etherscan.io/pushTx?%253Flang=zh-CN)| |
|LTC|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[PushTx](https://bch.btc.com/16Lp3ZvcusRGtqy7DgF5gz6PGutvuEtwRt)| |
|QTUM|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[PushTx](https://qtum.info/misc/raw-tx)|Support QRC20|
|USDT|‚úîÔ∏è|‚úîÔ∏è|‚úîÔ∏è|[DecodeTx](https://live.blockcypher.com/btc/decodetx/)„ÄÅ[Broadcast](https://blockchair.com/broadcast)| |


<!-- |--|‚úîÔ∏è|‚ùå|‚ùå| -->


## Environment Setup

- [Go Installation](https://golang.org/doc/install)
- [Gomobile Environment Setup](https://pkg.go.dev/golang.org/x/mobile/cmd/gomobile?tab=doc)
- In the hpywallet directory, compile the Android Reference Library:`gomobile bind -target=android .`
- In the hpywallet directory, compile the iOS Reference Library:`gomobile bind -target=ios .`
- About the missing librarys, use `go get xxx ..` to install them

## Mnemonic Generation

Generate mnemonics using the following method:

```go
func GenerateMnemonic() 
```

> Data structure returned, ` mnemonics`


### GenerateMnemonic Example
```go
mnemonic := hpywallet.GenerateMnemonic()
fmt.Println("Mnemonic: ", mnemonic)
```

## Seed Generation

Seed can be generated by `importing` the mnemonic & password.
Import mnemonics using the following method:

```go
func GenerateSeed(mnemonic string, password string)
```

> Data structure returned, ` hex seed`

### GenerateSeed Example
```go
mnemonic := "xxx xxx"
seed := hpywallet.GenerateSeed(mnemonic, "")
fmt.Println("Seed = ", seed)
```

## Use Mnemonics to generate wallet
Private key, public key and address can be generated by `importing` the mnemonic.
Import mnemonics using the following methods:

```go
func GenerateWallet(mnemonic string, coin string)
```

Data structure returned as followÔºö
```go
type WalletAccount struct {
	ResCode    int    // 0 fail 1 Success
	Address    string
	PublicKey  string
	PrivateKey string
	Seed       string // root seed
	Coin       string
	ErrMsg     string // fail messages
	ErrCode    int    // err code
	Params     []byte // reserved fields
}

```

### GenerateWallet Example
```go
mnemonic := "xxx xxx"
dogeWallet := hpywallet.GenerateWallet(mnemonic, "doge")
fmt.Println("dogeWallet: ", dogeWallet)
```

## use mnemonics & password to generate wallet
Private key, public key and address can be generated by `importing` mnemonics & password.
Import mnemonics & password using the following methods:

```go
func GenerateMnemonicWallet(mnemonic, password, coin string)
```

Data structure returned as `WalletAccount`

### GenerateMnemonicWallet Example
```go
mnemonic := "xxx xxx"
btcWallet := hpywallet.GenerateMnemonicWallet(mnemonic, "123456", "btc")
fmt.Println("btcWallet: ", btcWallet)
```

## Use the coin's Root Seed to generate wallet

Private key, public key and address can be generated by `importing` the root seed & coin.
Import seed & coin using the following methods:
```go
func GenerateSeedWallet(seed string, coin string)
```
Data structure returned as `WalletAccount`
### GenerateSeedWallet Example
```go
mnemonic := "xxx xxx"
btcWallet := hpywallet.GenerateSeedWallet(seed, "btc")
fmt.Println("btcWallet: ", btcWallet)
```

## Import private key (WIF) to generate wallet
Private key, public key and address can be generated by `importing` the WIF (Wallet Import Format) of the private key.

The following methods are used to create a wallet with a private key:

```go
func ImportPrivateWIF(wif string, coin string)
```
Data structure returned as `WalletAccount`
### ImportPrivateWIF Example
```go
mnemonic := "xxx xxx"
dogeWallet := hpywallet.GenerateWallet(mnemonic, "doge")
importWallet := hpywallet.ImportPrivateWIF(dogeWallet.PrivateKey, "doge")
fmt.Println("importWallet: ", importWallet)
```

## Mnemonics Or PrivateKey Generate KeyStore
The keystore file is generated by using the mnemonics or private key, UDID of the device and the password of the user's choosing.

To generate keystore file, use the following method:

```go
func EnKeystore(Key, password, udid string)
```

> Description: Key here can be either the mnemonic or the privatekey (WIF)

Data structure returned as :
```go
type KeystoreResult struct {
	Result  string
	ResCode int    // 0 fail 1 success
	ErrMsg  string // fail reason
}

```
### EnKeystore Example
```go
  Key := "L1oh9KNH4XpJgqDodxhjPgaEVS1qwXToWvPf2Zyn6bcm7xxxxxxx"
	pwd := "11111"
	udid := "AOIJF-QWEQR-VDFBET-YTAWWE"

	// Encode
	enResult := hpywallet.EnKeystore(Key, pwd, udid)
	fmt.Println("Keystore : \n", enResult.Result)
```
## KeyStore File Decrypt
The keystore file is decrypted using the KeyStore json, udid and the password.

To decrypt keystore file, use the following methods:


```go
func DeKeystore(json, password, udid string)
```

> Description: JSON is the KeyStore JSON file

Data structure returned as `KeystoreResult`„ÄÇ

### DeKeystore Example
```go
   enResult := "xxxxxxx"
	pwd := "11111"
	udid := "AOIJF-QWEQR-VDFBET-YTAWWE"
  // Decode
	deResult := hpywallet.DeKeystore(enResult, pwd, udid)
	fmt.Println("PrivateKey : ", deResult.Result)
```

## Sign a raw transaction

**SignInput**  Some parameters are optional, the data structure is illustrated as below:

```go
type SignInput struct {
	PrivateKey   string
	Coin         string
	Symbol       string
	Amount       int64  // transfer amount
	Change       int64  // transfer change amount
	Fee          int64  //transfer fee
	GasLimit     int64
	GasPrice     int64
	Type         string // contract type
	SrcAddr      string // send address
	DestAddr     string // destination address
	ContractAddr string // contract address
	Memo         string // memo mark
	Sequence     int64
	Inputs       []byte // vins
	Params       []byte // reserved fields
}
```
**method**:

```go
func SignRawTransaction(signIn *SignInput)
```

data structure returned as `SignResult` as below:

```go
type SignResult struct {
	ResCode int    // 0 fail 1 success
	Coin    string // name of the crypto token
	Symbol  string // symbol
	RawTX   string //  rawtx
	TxHash  string // tx hash
	ErrMsg  string // fail reason
	ErrCode int    // err code
	Params []byte // reserved field
}
```
### SignRawTransaction Example
```go
mnemonic := "xxx xxx"
btcWallet := hpywallet.GenerateWallet(mnemonic, "btc")
item1 := hpywallet.OutPutItem{
	TxHash:   "921784b1e11fcbfe267a04b9e54a45e597710d0f9413e658813737c06f44a987",
	Value:    1200000,
	Vout:     1,
	Pkscript: "76a914bc68c7efc2f672c3ea028e10ec321a9c68d5da7788ac",
}
outputs := []hpywallet.OutPutItem{item1}
jsonInputs, _ := json.Marshal(outputs)
signInput := &hpywallet.SignInput{
	Coin:       "btc",
	Symbol:     "btc",
	PrivateKey: btcWallet.PrivateKey,
	SrcAddr:    btcWallet.Address,
	DestAddr:   btcWallet.Address,
	Fee:        200000,
	Amount:     100000,
	Change:     900000,
	Inputs:     jsonInputs,
}
tranferResult := hpywallet.SignRawTransaction(signInput)
if tranferResult.ResCode == 0 {
	fmt.Println("Transfer btc Msg: ", tranferResult.ErrMsg)
} else {
	fmt.Println("Transfer btc RawTX: ", tranferResult.RawTX)
}
```


For the following main-chain currency, `Inputs` must be included in the call as part of the `SignInput` data:

- [x] BTC
- [x] USDT
- [x] LTC
- [x] QTUM
- [x] BCH
- [x] DASH

For any UTXO token, the `Inputs` attribute is `JsonArrayToByte[OutPutItem...].Bytes`

 The data structure about `OutPutItem`is as follows:

```go
type OutPutItem struct {
	TxHash   string
	Vout     uint32
	Value    int64
	Pkscript string // lock script
}
```

**!Please Note!**:
- Qtum QRC20 Transaction: the `ContractAddr` attribute is a required parameter;

## TODO LIST
**Features to be completed**
- [ ] Verify the token address
- [ ] Multi sign transaction
- [ ] Support more chains

## Thanks and more info.

Thanks `btcsuite`„ÄÅ`go-ethereum`„ÄÅ`blocktree` and others library.

[TOC]
